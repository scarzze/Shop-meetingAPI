<<<<<<< HEAD
# mypy: allow-untyped-defs, allow-incomplete-defs, allow-untyped-calls
# mypy: no-warn-return-any, allow-any-generics

from __future__ import annotations

import re
from typing import Any
from typing import Dict
=======
from __future__ import annotations

from typing import Any
>>>>>>> Salma
from typing import List
from typing import Optional
from typing import TYPE_CHECKING
from typing import Union

from sqlalchemy import types as sqltypes
<<<<<<< HEAD
=======
from sqlalchemy.ext.compiler import compiles
>>>>>>> Salma
from sqlalchemy.schema import Column
from sqlalchemy.schema import CreateIndex
from sqlalchemy.sql.base import Executable
from sqlalchemy.sql.elements import ClauseElement

from .base import AddColumn
from .base import alter_column
from .base import alter_table
from .base import ColumnDefault
from .base import ColumnName
from .base import ColumnNullable
from .base import ColumnType
from .base import format_column_name
from .base import format_server_default
from .base import format_table_name
from .base import format_type
from .base import RenameTable
from .impl import DefaultImpl
from .. import util
from ..util import sqla_compat
<<<<<<< HEAD
from ..util.sqla_compat import compiles
=======
>>>>>>> Salma

if TYPE_CHECKING:
    from typing import Literal

    from sqlalchemy.dialects.mssql.base import MSDDLCompiler
    from sqlalchemy.dialects.mssql.base import MSSQLCompiler
    from sqlalchemy.engine.cursor import CursorResult
<<<<<<< HEAD
=======
    from sqlalchemy.engine.cursor import LegacyCursorResult
>>>>>>> Salma
    from sqlalchemy.sql.schema import Index
    from sqlalchemy.sql.schema import Table
    from sqlalchemy.sql.selectable import TableClause
    from sqlalchemy.sql.type_api import TypeEngine

    from .base import _ServerDefault


class MSSQLImpl(DefaultImpl):
    __dialect__ = "mssql"
    transactional_ddl = True
    batch_separator = "GO"

    type_synonyms = DefaultImpl.type_synonyms + ({"VARCHAR", "NVARCHAR"},)
<<<<<<< HEAD
    identity_attrs_ignore = DefaultImpl.identity_attrs_ignore + (
=======
    identity_attrs_ignore = (
>>>>>>> Salma
        "minvalue",
        "maxvalue",
        "nominvalue",
        "nomaxvalue",
        "cycle",
        "cache",
<<<<<<< HEAD
    )

    def __init__(self, *arg, **kw) -> None:
        super().__init__(*arg, **kw)
=======
        "order",
        "on_null",
        "order",
    )

    def __init__(self, *arg, **kw) -> None:
        super(MSSQLImpl, self).__init__(*arg, **kw)
>>>>>>> Salma
        self.batch_separator = self.context_opts.get(
            "mssql_batch_separator", self.batch_separator
        )

<<<<<<< HEAD
    def _exec(self, construct: Any, *args, **kw) -> Optional[CursorResult]:
        result = super()._exec(construct, *args, **kw)
=======
    def _exec(
        self, construct: Any, *args, **kw
    ) -> Optional[Union["LegacyCursorResult", "CursorResult"]]:
        result = super(MSSQLImpl, self)._exec(construct, *args, **kw)
>>>>>>> Salma
        if self.as_sql and self.batch_separator:
            self.static_output(self.batch_separator)
        return result

    def emit_begin(self) -> None:
        self.static_output("BEGIN TRANSACTION" + self.command_terminator)

    def emit_commit(self) -> None:
<<<<<<< HEAD
        super().emit_commit()
=======
        super(MSSQLImpl, self).emit_commit()
>>>>>>> Salma
        if self.as_sql and self.batch_separator:
            self.static_output(self.batch_separator)

    def alter_column(  # type:ignore[override]
        self,
        table_name: str,
        column_name: str,
        nullable: Optional[bool] = None,
        server_default: Optional[
<<<<<<< HEAD
            Union[_ServerDefault, Literal[False]]
        ] = False,
        name: Optional[str] = None,
        type_: Optional[TypeEngine] = None,
        schema: Optional[str] = None,
        existing_type: Optional[TypeEngine] = None,
        existing_server_default: Optional[_ServerDefault] = None,
        existing_nullable: Optional[bool] = None,
        **kw: Any,
    ) -> None:
=======
            Union["_ServerDefault", "Literal[False]"]
        ] = False,
        name: Optional[str] = None,
        type_: Optional["TypeEngine"] = None,
        schema: Optional[str] = None,
        existing_type: Optional["TypeEngine"] = None,
        existing_server_default: Optional["_ServerDefault"] = None,
        existing_nullable: Optional[bool] = None,
        **kw: Any,
    ) -> None:

>>>>>>> Salma
        if nullable is not None:
            if type_ is not None:
                # the NULL/NOT NULL alter will handle
                # the type alteration
                existing_type = type_
                type_ = None
            elif existing_type is None:
                raise util.CommandError(
                    "MS-SQL ALTER COLUMN operations "
                    "with NULL or NOT NULL require the "
                    "existing_type or a new type_ be passed."
                )
        elif existing_nullable is not None and type_ is not None:
            nullable = existing_nullable

            # the NULL/NOT NULL alter will handle
            # the type alteration
            existing_type = type_
            type_ = None

        elif type_ is not None:
            util.warn(
                "MS-SQL ALTER COLUMN operations that specify type_= "
                "should also specify a nullable= or "
                "existing_nullable= argument to avoid implicit conversion "
                "of NOT NULL columns to NULL."
            )

        used_default = False
        if sqla_compat._server_default_is_identity(
            server_default, existing_server_default
        ) or sqla_compat._server_default_is_computed(
            server_default, existing_server_default
        ):
            used_default = True
            kw["server_default"] = server_default
            kw["existing_server_default"] = existing_server_default

<<<<<<< HEAD
        super().alter_column(
=======
        super(MSSQLImpl, self).alter_column(
>>>>>>> Salma
            table_name,
            column_name,
            nullable=nullable,
            type_=type_,
            schema=schema,
            existing_type=existing_type,
            existing_nullable=existing_nullable,
            **kw,
        )

        if server_default is not False and used_default is False:
            if existing_server_default is not False or server_default is None:
                self._exec(
                    _ExecDropConstraint(
                        table_name,
                        column_name,
                        "sys.default_constraints",
                        schema,
                    )
                )
            if server_default is not None:
<<<<<<< HEAD
                super().alter_column(
=======
                super(MSSQLImpl, self).alter_column(
>>>>>>> Salma
                    table_name,
                    column_name,
                    schema=schema,
                    server_default=server_default,
                )

        if name is not None:
<<<<<<< HEAD
            super().alter_column(
                table_name, column_name, schema=schema, name=name
            )

    def create_index(self, index: Index, **kw: Any) -> None:
=======
            super(MSSQLImpl, self).alter_column(
                table_name, column_name, schema=schema, name=name
            )

    def create_index(self, index: "Index") -> None:
>>>>>>> Salma
        # this likely defaults to None if not present, so get()
        # should normally not return the default value.  being
        # defensive in any case
        mssql_include = index.kwargs.get("mssql_include", None) or ()
        assert index.table is not None
        for col in mssql_include:
            if col not in index.table.c:
                index.table.append_column(Column(col, sqltypes.NullType))
<<<<<<< HEAD
        self._exec(CreateIndex(index, **kw))

    def bulk_insert(  # type:ignore[override]
        self, table: Union[TableClause, Table], rows: List[dict], **kw: Any
=======
        self._exec(CreateIndex(index))

    def bulk_insert(  # type:ignore[override]
        self, table: Union["TableClause", "Table"], rows: List[dict], **kw: Any
>>>>>>> Salma
    ) -> None:
        if self.as_sql:
            self._exec(
                "SET IDENTITY_INSERT %s ON"
                % self.dialect.identifier_preparer.format_table(table)
            )
<<<<<<< HEAD
            super().bulk_insert(table, rows, **kw)
=======
            super(MSSQLImpl, self).bulk_insert(table, rows, **kw)
>>>>>>> Salma
            self._exec(
                "SET IDENTITY_INSERT %s OFF"
                % self.dialect.identifier_preparer.format_table(table)
            )
        else:
<<<<<<< HEAD
            super().bulk_insert(table, rows, **kw)
=======
            super(MSSQLImpl, self).bulk_insert(table, rows, **kw)
>>>>>>> Salma

    def drop_column(
        self,
        table_name: str,
<<<<<<< HEAD
        column: Column[Any],
=======
        column: "Column",
>>>>>>> Salma
        schema: Optional[str] = None,
        **kw,
    ) -> None:
        drop_default = kw.pop("mssql_drop_default", False)
        if drop_default:
            self._exec(
                _ExecDropConstraint(
                    table_name, column, "sys.default_constraints", schema
                )
            )
        drop_check = kw.pop("mssql_drop_check", False)
        if drop_check:
            self._exec(
                _ExecDropConstraint(
                    table_name, column, "sys.check_constraints", schema
                )
            )
        drop_fks = kw.pop("mssql_drop_foreign_key", False)
        if drop_fks:
            self._exec(_ExecDropFKConstraint(table_name, column, schema))
<<<<<<< HEAD
        super().drop_column(table_name, column, schema=schema, **kw)
=======
        super(MSSQLImpl, self).drop_column(
            table_name, column, schema=schema, **kw
        )
>>>>>>> Salma

    def compare_server_default(
        self,
        inspector_column,
        metadata_column,
        rendered_metadata_default,
        rendered_inspector_default,
    ):
<<<<<<< HEAD
        if rendered_metadata_default is not None:
            rendered_metadata_default = re.sub(
                r"[\(\) \"\']", "", rendered_metadata_default
            )

        if rendered_inspector_default is not None:
            # SQL Server collapses whitespace and adds arbitrary parenthesis
            # within expressions.   our only option is collapse all of it

            rendered_inspector_default = re.sub(
                r"[\(\) \"\']", "", rendered_inspector_default
            )

        return rendered_inspector_default != rendered_metadata_default

    def _compare_identity_default(self, metadata_identity, inspector_identity):
        diff, ignored, is_alter = super()._compare_identity_default(
            metadata_identity, inspector_identity
        )
=======
        def clean(value):
            if value is not None:
                value = value.strip()
                while value[0] == "(" and value[-1] == ")":
                    value = value[1:-1]
            return value

        return clean(rendered_inspector_default) != clean(
            rendered_metadata_default
        )

    def _compare_identity_default(self, metadata_identity, inspector_identity):
        diff, ignored, is_alter = super(
            MSSQLImpl, self
        )._compare_identity_default(metadata_identity, inspector_identity)
>>>>>>> Salma

        if (
            metadata_identity is None
            and inspector_identity is not None
            and not diff
            and inspector_identity.column is not None
            and inspector_identity.column.primary_key
        ):
            # mssql reflect primary keys with autoincrement as identity
            # columns. if no different attributes are present ignore them
            is_alter = False

        return diff, ignored, is_alter

<<<<<<< HEAD
    def adjust_reflected_dialect_options(
        self, reflected_object: Dict[str, Any], kind: str
    ) -> Dict[str, Any]:
        options: Dict[str, Any]
        options = reflected_object.get("dialect_options", {}).copy()
        if not options.get("mssql_include"):
            options.pop("mssql_include", None)
        if not options.get("mssql_clustered"):
            options.pop("mssql_clustered", None)
        return options

=======
>>>>>>> Salma

class _ExecDropConstraint(Executable, ClauseElement):
    inherit_cache = False

    def __init__(
        self,
        tname: str,
<<<<<<< HEAD
        colname: Union[Column[Any], str],
=======
        colname: Union["Column", str],
>>>>>>> Salma
        type_: str,
        schema: Optional[str],
    ) -> None:
        self.tname = tname
        self.colname = colname
        self.type_ = type_
        self.schema = schema


class _ExecDropFKConstraint(Executable, ClauseElement):
    inherit_cache = False

    def __init__(
<<<<<<< HEAD
        self, tname: str, colname: Column[Any], schema: Optional[str]
=======
        self, tname: str, colname: "Column", schema: Optional[str]
>>>>>>> Salma
    ) -> None:
        self.tname = tname
        self.colname = colname
        self.schema = schema


@compiles(_ExecDropConstraint, "mssql")
def _exec_drop_col_constraint(
<<<<<<< HEAD
    element: _ExecDropConstraint, compiler: MSSQLCompiler, **kw
=======
    element: "_ExecDropConstraint", compiler: "MSSQLCompiler", **kw
>>>>>>> Salma
) -> str:
    schema, tname, colname, type_ = (
        element.schema,
        element.tname,
        element.colname,
        element.type_,
    )
    # from http://www.mssqltips.com/sqlservertip/1425/\
    # working-with-default-constraints-in-sql-server/
<<<<<<< HEAD
    return """declare @const_name varchar(256)
select @const_name = QUOTENAME([name]) from %(type)s
=======
    # TODO: needs table formatting, etc.
    return """declare @const_name varchar(256)
select @const_name = [name] from %(type)s
>>>>>>> Salma
where parent_object_id = object_id('%(schema_dot)s%(tname)s')
and col_name(parent_object_id, parent_column_id) = '%(colname)s'
exec('alter table %(tname_quoted)s drop constraint ' + @const_name)""" % {
        "type": type_,
        "tname": tname,
        "colname": colname,
        "tname_quoted": format_table_name(compiler, tname, schema),
        "schema_dot": schema + "." if schema else "",
    }


@compiles(_ExecDropFKConstraint, "mssql")
def _exec_drop_col_fk_constraint(
<<<<<<< HEAD
    element: _ExecDropFKConstraint, compiler: MSSQLCompiler, **kw
=======
    element: "_ExecDropFKConstraint", compiler: "MSSQLCompiler", **kw
>>>>>>> Salma
) -> str:
    schema, tname, colname = element.schema, element.tname, element.colname

    return """declare @const_name varchar(256)
<<<<<<< HEAD
select @const_name = QUOTENAME([name]) from
=======
select @const_name = [name] from
>>>>>>> Salma
sys.foreign_keys fk join sys.foreign_key_columns fkc
on fk.object_id=fkc.constraint_object_id
where fkc.parent_object_id = object_id('%(schema_dot)s%(tname)s')
and col_name(fkc.parent_object_id, fkc.parent_column_id) = '%(colname)s'
exec('alter table %(tname_quoted)s drop constraint ' + @const_name)""" % {
        "tname": tname,
        "colname": colname,
        "tname_quoted": format_table_name(compiler, tname, schema),
        "schema_dot": schema + "." if schema else "",
    }


@compiles(AddColumn, "mssql")
<<<<<<< HEAD
def visit_add_column(element: AddColumn, compiler: MSDDLCompiler, **kw) -> str:
=======
def visit_add_column(
    element: "AddColumn", compiler: "MSDDLCompiler", **kw
) -> str:
>>>>>>> Salma
    return "%s %s" % (
        alter_table(compiler, element.table_name, element.schema),
        mssql_add_column(compiler, element.column, **kw),
    )


<<<<<<< HEAD
def mssql_add_column(
    compiler: MSDDLCompiler, column: Column[Any], **kw
) -> str:
=======
def mssql_add_column(compiler: "MSDDLCompiler", column: "Column", **kw) -> str:
>>>>>>> Salma
    return "ADD %s" % compiler.get_column_specification(column, **kw)


@compiles(ColumnNullable, "mssql")
def visit_column_nullable(
<<<<<<< HEAD
    element: ColumnNullable, compiler: MSDDLCompiler, **kw
=======
    element: "ColumnNullable", compiler: "MSDDLCompiler", **kw
>>>>>>> Salma
) -> str:
    return "%s %s %s %s" % (
        alter_table(compiler, element.table_name, element.schema),
        alter_column(compiler, element.column_name),
<<<<<<< HEAD
        format_type(compiler, element.existing_type),  # type: ignore[arg-type]
=======
        format_type(compiler, element.existing_type),
>>>>>>> Salma
        "NULL" if element.nullable else "NOT NULL",
    )


@compiles(ColumnDefault, "mssql")
def visit_column_default(
<<<<<<< HEAD
    element: ColumnDefault, compiler: MSDDLCompiler, **kw
=======
    element: "ColumnDefault", compiler: "MSDDLCompiler", **kw
>>>>>>> Salma
) -> str:
    # TODO: there can also be a named constraint
    # with ADD CONSTRAINT here
    return "%s ADD DEFAULT %s FOR %s" % (
        alter_table(compiler, element.table_name, element.schema),
        format_server_default(compiler, element.default),
        format_column_name(compiler, element.column_name),
    )


@compiles(ColumnName, "mssql")
def visit_rename_column(
<<<<<<< HEAD
    element: ColumnName, compiler: MSDDLCompiler, **kw
=======
    element: "ColumnName", compiler: "MSDDLCompiler", **kw
>>>>>>> Salma
) -> str:
    return "EXEC sp_rename '%s.%s', %s, 'COLUMN'" % (
        format_table_name(compiler, element.table_name, element.schema),
        format_column_name(compiler, element.column_name),
        format_column_name(compiler, element.newname),
    )


@compiles(ColumnType, "mssql")
def visit_column_type(
<<<<<<< HEAD
    element: ColumnType, compiler: MSDDLCompiler, **kw
=======
    element: "ColumnType", compiler: "MSDDLCompiler", **kw
>>>>>>> Salma
) -> str:
    return "%s %s %s" % (
        alter_table(compiler, element.table_name, element.schema),
        alter_column(compiler, element.column_name),
        format_type(compiler, element.type_),
    )


@compiles(RenameTable, "mssql")
def visit_rename_table(
<<<<<<< HEAD
    element: RenameTable, compiler: MSDDLCompiler, **kw
=======
    element: "RenameTable", compiler: "MSDDLCompiler", **kw
>>>>>>> Salma
) -> str:
    return "EXEC sp_rename '%s', %s" % (
        format_table_name(compiler, element.table_name, element.schema),
        format_table_name(compiler, element.new_table_name, None),
    )
